/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.jenkins.plugins.containersecurity;

import static com.google.jenkins.plugins.containersecurity.client.ClientUtil.getClientFactory;
import static com.google.jenkins.plugins.containersecurity.util.DescriptorUtil.checkPermissions;
import static com.google.jenkins.plugins.containersecurity.util.DescriptorUtil.validateRequiredFields;

import com.google.api.services.containeranalysis.v1beta1.model.Occurrence;
import com.google.cloud.graphite.platforms.plugin.client.ContainerAnalysisClient;
import com.google.common.collect.ImmutableList;
import hudson.AbortException;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import jenkins.model.Jenkins;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;
import org.awaitility.core.ConditionTimeoutException;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;

/**
 * A step for a {@link GcspBuild} that polls the Container Analysis API for vulnerability scan
 * results for a container image and presents those results to the user, with the option to fail the
 * build if the vulnerabilities exceed a Severity threshold.
 */
@Getter
@Setter(onMethod = @__(@DataBoundSetter))
@NoArgsConstructor(onConstructor = @__(@DataBoundConstructor))
public class VulnerabilityScanStep extends AbstractGcspBuildStep {
  private static final long MINIMUM_TIMEOUT = 30000;
  private long timeout = MINIMUM_TIMEOUT;
  private Severity severityThreshold;

  void perform(
      @NonNull GcspBuild parent,
      @NonNull Run<?, ?> run,
      @NonNull FilePath workspace,
      @NonNull Launcher launcher,
      @NonNull TaskListener listener)
      throws IOException, InterruptedException {
    ContainerAnalysisClient containerAnalysisClient =
        getClientFactory(Jenkins.get(), parent.getCredentialsId()).containerAnalysisClient();

    String scanStatus;
    try {
      scanStatus =
          containerAnalysisClient.getVulnerabilityScanStatusSync(
              parent.getProjectId(), "https://" + parent.getResolvedContainerUri(), timeout);
    } catch (IllegalArgumentException e) {
      listener.getLogger().println("Could not get vulnerability scan status: " + e.getMessage());
      throw e;
    } catch (ConditionTimeoutException e) {
      listener
          .getLogger()
          .println("Timed out waiting for vulnerability scan to finish: " + e.getMessage());
      throw e;
    }
    int count = 0;
    switch (scanStatus) {
      case "FINISHED_UNSUPPORTED":
        listener.getLogger().println("Could not scan container as it was unsupported.");
        break;
      case "FINISHED_FAILURE":
        listener.getLogger().println("Container Analysis failed to scan the provided binary.");
        break;
      case "FINISHED_SUCCESS":
        List<Occurrence> vulnerabilities =
            containerAnalysisClient.listVulnerabilityScanOccurrences(
                parent.getProjectId(), "https://" + parent.getResolvedContainerUri());
        int[] counts = getCounts(vulnerabilities);
        listener.getLogger().println("Vulnerability Scan Summary");
        listener.getLogger().println(getVulnerabilitySummary(vulnerabilities, counts));
        count = totalAboveThreshold(counts, severityThreshold);
        break;
      default:
        throw new AbortException("Vulnerability scan finished in unknown state: " + scanStatus);
    }

    listener
        .getLogger()
        .println("Find more information at: https://" + parent.getResolvedContainerUri());
    if (count > 0) {
      throw new AbortException(
          String.format(
              "Vulnerability scan failed to pass: %d vulnerabilities above threshold.", count));
    }
  }

  private String getVulnerabilitySummary(List<Occurrence> vulnerabilities, int[] counts) {
    return String.format(
        "Total: %d | Critical: %d | High: %d | Medium: %d | Low: %d | Unspecified: %d",
        vulnerabilities.size(),
        counts[Severity.CRITICAL.getValue()],
        counts[Severity.HIGH.getValue()],
        counts[Severity.MEDIUM.getValue()],
        counts[Severity.LOW.getValue()],
        counts[Severity.UNSPECIFIED.getValue()]);
  }

  private int[] getCounts(List<Occurrence> vulnerabilities) {
    int[] counts = new int[Severity.values().length];
    vulnerabilities.stream()
        .map(v -> Severity.valueOfNullable(v.getVulnerability().getEffectiveSeverity()).getValue())
        .forEach(s -> counts[s]++);
    return counts;
  }

  private int totalAboveThreshold(int[] counts, Severity severityThreshold) {
    int result = 0;
    for (int i = severityThreshold.getValue(); i < counts.length; i++) {
      result += counts[i];
    }
    return result;
  }

  /** Descriptor implementation for {@link VulnerabilityScanStep}. */
  @Extension
  public static class DescriptorImpl extends AbstractGcspBuildStepDescriptor {
    /** Constructor for {@link VulnerabilityScanStep.DescriptorImpl}. */
    public DescriptorImpl() {
      super(VulnerabilityScanStep.class);
    }

    /** {@inheritDoc} */
    @Override
    public String getDisplayName() {
      return Messages.VulnerabilityScanStep_DisplayName();
    }

    /**
     * Checks that the timeout is a value of at least 30000 milliseconds.
     *
     * @param timeout The value entered in the timeout field.
     * @return A {@link FormValidation}: FormValidation.ok() if the timeout is valid, or
     *     FormValidation.error with a status message indicating the issue with provided value.
     */
    public FormValidation doCheckTimeout(@QueryParameter("timeout") final String timeout) {
      checkPermissions();
      return validateRequiredFields(
          ImmutableList.of(timeout),
          ImmutableList.of(Messages.VulnerabilityScanStep_TimeoutRequired()),
          () -> {
            try {
              if (Long.parseLong(timeout) < MINIMUM_TIMEOUT) {
                return FormValidation.error(
                    Messages.VulnerabilityScanStep_TimeoutInvalid(MINIMUM_TIMEOUT));
              }
              return FormValidation.ok();
            } catch (NumberFormatException nfe) {
              return FormValidation.error(
                  Messages.VulnerabilityScanStep_TimeoutInvalid(MINIMUM_TIMEOUT));
            }
          });
    }

    /**
     * Fills the severity threshold dropdown with the names of all values of {@link Severity}.
     *
     * @return The {@link ListBoxModel} containing the dropdown items.
     */
    public ListBoxModel doFillSeverityThresholdItems() {
      checkPermissions();
      ListBoxModel result = new ListBoxModel();
      Arrays.stream(Severity.values()).forEach(s -> result.add(s.name()));
      return result;
    }

    /**
     * Checks that the selected severityThreshold is one of the values of {@link Severity}.
     *
     * @param severityThreshold The name of the {@link Severity} value to check.
     * @return A {@link FormValidation}: FormValidation.ok() if the provided name is a valid {@link
     *     Severity} or FormValidation.error with a status message indicating the issue.
     */
    public FormValidation doCheckSeverityThreshold(
        @QueryParameter("severityThreshold") final String severityThreshold) {
      checkPermissions();
      return validateRequiredFields(
          ImmutableList.of(severityThreshold),
          ImmutableList.of(Messages.VulnerabilityScanStep_SeverityThresholdRequired()),
          () -> {
            try {
              Severity.valueOf(severityThreshold);
              return FormValidation.ok();
            } catch (IllegalArgumentException iae) {
              return FormValidation.error(
                  Messages.VulnerabilityScanStep_SeverityThresholdInvalid(severityThreshold));
            }
          });
    }
  }
}
